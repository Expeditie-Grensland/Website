import {LegacyTableData, TableData, Tables} from "./Tables"
import {Util} from "./Util"
import {Route} from "./Route"
import LocationDocument = TableData.Location.LocationDocument
import * as mongoose from "mongoose";
import {LocationHelper} from "../helper/LocationHelper"

export namespace Location {

    import LocationOrID = TableData.LocationOrID
    import RouteOrID = TableData.RouteOrID
    import getRoute = Route.getRoute
    import PersonOrID = TableData.PersonOrID
    import RouteNodeDocument = TableData.RouteNode.RouteNodeDocument
    import RouteNodeOrID = TableData.RouteNodeOrID
    import ZoomLevel = LocationHelper.ZoomLevel

    export function getLocationById(_id: string): Promise<LocationDocument> {
        return Tables.Location.findById(_id).exec()
    }

    export function getLocationsById(ids: string[]): Promise<LocationDocument[]> {
        return Tables.Location.find({_id: {$in: ids}}).exec()
    }

    export function getLocation(location: LocationOrID): Promise<LocationDocument> {
        return Util.getDocument(location, getLocationById)
    }

    export function getLocations(locations: LocationOrID[]): Promise<LocationDocument[]> {
        return Util.getDocuments(locations, getLocationsById)
    }

    export function createLocation(location: TableData.Location.Location, route: RouteOrID): Promise<LocationDocument> {
        return getRoute(route).then(route => {
            if (location.node === undefined) {
                return Route.getCurrentNodeWithPerson(location.person)(route).then(routeNode => {
                    location.node = Util.getObjectID(routeNode)
                    return location
                })
            }

            if(location.zoomLevel === undefined) {
                location.zoomLevel = 0
            }

            return location
        }).then(location => {
            return Tables.Location.create(location)
        }).then(LocationHelper.calculateZoomLevel)
    }

    export function createLocations(locations: TableData.Location.Location[], route: RouteOrID): Promise<LocationDocument[]> {
        return getRoute(route).then(route => {

            let currentNodeWithPerson: Map<string, Promise<RouteNodeDocument>> = new Map()

            function currentNodeWithPersonCached(person: PersonOrID): Promise<RouteNodeDocument> {
                if(!currentNodeWithPerson.has(Util.getObjectID(person))) {
                    currentNodeWithPerson.set(Util.getObjectID(person), Route.getCurrentNodeWithPerson(person)(route))
                }
                return currentNodeWithPerson.get(Util.getObjectID(person))
            }

            return Promise.all(locations.map(location => {
                if(location.zoomLevel === undefined) {
                    location.zoomLevel = 0
                }

                if (location.node === undefined) {
                    return currentNodeWithPersonCached(location.person).then(routeNode => {
                        location.node = Util.getObjectID(routeNode)
                        return location
                    })
                }

                return Promise.resolve(location)
            }))
        }).then(locations => {
            return Tables.Location.insertMany(locations)
        }).then(LocationHelper.calculateZoomLevels)
    }

    export function removeLocation(location): Promise<void> {
        return getLocation(location).then(document => {
            return document.remove()
        }).then(() => null)
    }

    export function setLocationZoomLevel(zoomLevel: number): (location: LocationOrID) => Promise<LocationDocument> {
        return (location) => Tables.Location.findByIdAndUpdate(Util.getObjectID(location), {zoomLevel: zoomLevel}, {new: true}).exec()
    }

    export function getLocationsInRoute(route: RouteOrID): Promise<LocationDocument[]> {
        return Route.getNodes(route).then(nodes => Tables.Location.find({node: {$in: Util.getObjectIDs(nodes)}}).exec())
    }

    export function getLocationsInRouteAtZoomLevel(zoomLevel: ZoomLevel): (route: RouteOrID) => Promise<LocationDocument[]> {
        return route => Route.getNodes(route).then(nodes => Tables.Location.find({node: {$in: Util.getObjectIDs(nodes)}, zoomLevel: zoomLevel}).exec())
    }

    export function getLocationsInNode(node: RouteNodeOrID): Promise<LocationDocument[]> {
        return Tables.Location.find({node: Util.getObjectID(node)}).exec()
    }

    export function fromKaukasusLegacy(location: LegacyTableData.Kaukasus.LocationJSON, person: PersonOrID): TableData.Location.Location {
        return {
            person: Util.getObjectID(person),
            timestamp: Math.floor(location.stamp / 1000),
            timezone: location.timezone,
            lat: location.lat,
            lon: location.lon,
            altitude: location.alt,
        }
    }

    /**
     * Remove enormous amounts of unnecessary data generated by stupid, badly-implemented ping function.
     */
    export function removePingData(locations: LegacyTableData.Kaukasus.LocationJSON[], person: PersonOrID): TableData.Location.Location[] {
        let idx = 0
        let l: TableData.Location.Location[] = []
        let duplicateCount = 0

        while(true) {
            if(idx >= locations.length)
                break

            const current = locations[idx]

            l.push(fromKaukasusLegacy(current, person))

            let i = 0

            for(i = idx+1; i < locations.length; i++) {
                const next = locations[i]

                if(next.lat === current.lat && next.lon === current.lon && next.alt == current.alt) {
                    duplicateCount++
                } else {
                    break
                }
            }

            idx = i
        }

        console.log("Skipped " + duplicateCount + " of " + locations.length + " locations.")

        return l
    }
}