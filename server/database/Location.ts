import {LegacyTableData, TableData, Tables} from "./Tables"
import {Util} from "./Util"
import {Route} from "./Route"
import LocationDocument = TableData.Location.LocationDocument
const geoTz: any = require('geo-tz')
import {LocationHelper} from "../helper/LocationHelper"

export namespace Location {

    import LocationOrID = TableData.LocationOrID
    import RouteOrID = TableData.RouteOrID
    import getRoute = Route.getRoute
    import PersonOrID = TableData.PersonOrID
    import RouteNodeDocument = TableData.RouteNode.RouteNodeDocument
    import RouteNodeOrID = TableData.RouteNodeOrID
    import ZoomLevel = LocationHelper.ZoomLevel

    export function getLocationById(_id: string): Promise<LocationDocument> {
        return Tables.Location.findById(_id).exec()
    }

    export function getLocationsById(ids: string[]): Promise<LocationDocument[]> {
        return Tables.Location.find({_id: {$in: ids}}).exec()
    }

    export function getLocation(location: LocationOrID): Promise<LocationDocument> {
        return Util.getDocument(location, getLocationById)
    }

    export function getLocations(locations: LocationOrID[]): Promise<LocationDocument[]> {
        return Util.getDocuments(locations, getLocationsById)
    }

    export async function createLocation(location: TableData.Location.Location, route: RouteOrID): Promise<LocationDocument> {
        const routeDoc = await getRoute(route)

        if(location.node === undefined) {
            const node = await Route.getCurrentNodeWithPerson(location.person)(routeDoc)
            location.node = Util.getObjectID(node)
        }

        if(location.zoomLevel === undefined) {
            location.zoomLevel = 0
        }

        const locationDoc = await Tables.Location.create(location)

        await Route.expandBoundingBox([locationDoc])(routeDoc)

        return LocationHelper.calculateZoomLevel(locationDoc)
    }

    export async function createLocations(locations: TableData.Location.Location[], route: RouteOrID): Promise<LocationDocument[]> {
        const routeDoc = await getRoute(route)

        let currentNodeWithPerson: Map<string, Promise<RouteNodeDocument>> = new Map()

        function currentNodeWithPersonCached(person: PersonOrID): Promise<RouteNodeDocument> {
            if(!currentNodeWithPerson.has(Util.getObjectID(person))) {
                currentNodeWithPerson.set(Util.getObjectID(person), Route.getCurrentNodeWithPerson(person)(routeDoc))
            }
            return currentNodeWithPerson.get(Util.getObjectID(person))
        }

        for(let location of locations) {
            if(location.zoomLevel === undefined) {
                location.zoomLevel = 0
            }

            if(location.node === undefined) {
                const node = await currentNodeWithPersonCached(location.person)
                location.node = Util.getObjectID(node)
            }
        }

        const locationDocs = await Tables.Location.insertMany(locations)

        await Route.expandBoundingBox(locationDocs)(routeDoc)

        return LocationHelper.calculateZoomLevels(locationDocs)
    }

    export function removeLocation(location): Promise<void> {
        return getLocation(location).then(document => {
            return document.remove()
        }).then(() => null)
    }

    export function setLocationZoomLevel(zoomLevel: number): (location: LocationOrID) => Promise<LocationDocument> {
        return (location) => Tables.Location.findByIdAndUpdate(Util.getObjectID(location), {zoomLevel: zoomLevel}, {new: true}).exec()
    }

    export function getLocationsInRoute(route: RouteOrID): Promise<LocationDocument[]> {
        return Route.getNodes(route).then(nodes => Tables.Location.find({node: {$in: Util.getObjectIDs(nodes)}}).exec())
    }

    export function getLocationsInRouteAtZoomLevel(zoomLevel: ZoomLevel): (route: RouteOrID) => Promise<LocationDocument[]> {
        return route => Route.getNodes(route).then(nodes => Tables.Location.find({node: {$in: Util.getObjectIDs(nodes)}, zoomLevel: zoomLevel}).exec())
    }

    export function getLocationsInNode(node: RouteNodeOrID): Promise<LocationDocument[]> {
        return Tables.Location.find({node: Util.getObjectID(node)}).exec()
    }

    export function fromKaukasusLegacy(location: LegacyTableData.Kaukasus.LocationJSON, person: PersonOrID): TableData.Location.Location {
        return {
            person: Util.getObjectID(person),
            timestamp: Math.floor(location.stamp / 1000),
            timezone: location.timezone,
            lat: location.lat,
            lon: location.lon,
            altitude: location.alt,
        }
    }

    /**
     * Remove enormous amounts of unnecessary data generated by stupid, badly-implemented ping function.
     */
    export function removePingData(locations: LegacyTableData.Kaukasus.LocationJSON[], person: PersonOrID): TableData.Location.Location[] {
        let idx = 0
        let l: TableData.Location.Location[] = []
        let duplicateCount = 0

        while(true) {
            if(idx >= locations.length)
                break

            const current = locations[idx]

            l.push(fromKaukasusLegacy(current, person))

            let i = 0

            for(i = idx+1; i < locations.length; i++) {
                const next = locations[i]

                if(next.lat === current.lat && next.lon === current.lon && next.alt == current.alt) {
                    duplicateCount++
                } else {
                    break
                }
            }

            idx = i
        }

        console.log("Skipped " + duplicateCount + " of " + locations.length + " locations.")

        return l
    }

    export function fromBalkanLegacy(location: LegacyTableData.Balkan.LocationJSON, previousAltitude: number, person: PersonOrID): TableData.Location.Location {
        const lat = location.latitudeE7 / 10E6
        const lon = location.longitudeE7 / 10E6
        return {
            person: Util.getObjectID(person),
            timestamp: Math.floor(parseInt(location.timestampMs) / 1000),
            timezone: geoTz.tz(lat, lon),
            lat: lat,
            lon: lon,
            altitude: location.altitude === undefined ? previousAltitude : location.altitude,
        }
    }
}